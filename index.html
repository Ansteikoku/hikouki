<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>本格フライトシム</title>
<style>
body{margin:0; overflow:hidden; background:#87CEEB;}
#hud{position:absolute; top:10px; left:10px; color:#0f0; font-family:monospace; background:rgba(0,0,0,0.3); padding:10px; border-radius:5px;}
#hud div{margin:2px 0;}
#engineHUD{position:absolute; bottom:50px; left:10px; color:#0f0;}
#compass{position:absolute; bottom:10px; left:50%; transform:translateX(-50%); color:#0f0;}
#artificialHorizon{position:absolute; top:10px; right:10px; border:1px solid #0f0; background:rgba(0,0,0,0.3);}
</style>
</head>
<body>

<div id="hud">
  <div id="speed">Speed: 0 m/s</div>
  <div id="altitude">Altitude: 0 m</div>
  <div id="aoa">AoA: 0°</div>
</div>

<canvas id="artificialHorizon" width="150" height="150"></canvas>
<div id="compass">Heading: 0°</div>
<div id="engineHUD">
  <div id="thrust">Thrust: 0 N</div>
  <div id="fuel">Fuel: 100 kg</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script>
// ----- 機体パラメータ -----
let mass = 1000; // kg
const wingArea = 16;
const maxAoA = Math.PI/6;
const g = 9.81;
const controlLag = 0.2;
let fuel = 100; 
const fuelRateMax = 0.5; 

// ----- 状態変数 -----
let position = new THREE.Vector3(0,50,0);
let velocity = new THREE.Vector3(50,0,0);
let rotation = new THREE.Euler();
let angularVelocity = new THREE.Vector3();
let throttle = 0.5;
let pitchInput=0, rollInput=0, yawInput=0;
let pitchInputFiltered=0, rollInputFiltered=0, yawInputFiltered=0;

// ----- Three.js セットアップ -----
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ----- 簡易地形 -----
const groundGeo = new THREE.PlaneGeometry(2000,2000,50,50);
groundGeo.rotateX(-Math.PI/2);
for(let i=0;i<groundGeo.attributes.position.count;i++){
  groundGeo.attributes.position.setY(i, Math.random()*5);
}
const groundMat = new THREE.MeshPhongMaterial({color:0x228B22});
const ground = new THREE.Mesh(groundGeo, groundMat);
scene.add(ground);

// ----- 飛行機 -----
const planeGeo = new THREE.ConeGeometry(1,3,8);
const planeMat = new THREE.MeshBasicMaterial({color:0xff0000});
const plane = new THREE.Mesh(planeGeo, planeMat);
scene.add(plane);

// ----- 光源 -----
const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(100,200,100);
scene.add(light);

// ----- 入力 -----
document.addEventListener('keydown', e=>{
  if(e.key==='w') pitchInput=1;
  if(e.key==='s') pitchInput=-1;
  if(e.key==='a') rollInput=1;
  if(e.key==='d') rollInput=-1;
  if(e.key==='ArrowLeft') yawInput=1;
  if(e.key==='ArrowRight') yawInput=-1;
  if(e.key==='ArrowUp') throttle=Math.min(throttle+0.05,1);
  if(e.key==='ArrowDown') throttle=Math.max(throttle-0.05,0);
});
document.addEventListener('keyup', e=>{
  if(['w','s'].includes(e.key)) pitchInput=0;
  if(['a','d'].includes(e.key)) rollInput=0;
  if(['ArrowLeft','ArrowRight'].includes(e.key)) yawInput=0;
});

// ----- 空気力学 -----
function airDensity(alt){ return 1.225*Math.exp(-alt/8500); }
function liftCoefficient(aoa){ return aoa>maxAoA?0.5*(1-(aoa-maxAoA)/maxAoA):2*Math.PI*aoa; }
function dragCoefficient(aoa){ return 0.02+0.04*aoa*aoa; }
function windForce(){ return new THREE.Vector3((Math.random()-0.5)*5,(Math.random()-0.5)*2,(Math.random()-0.5)*5); }

// ----- 推力・燃料 -----
function thrustCurve(throttle, altitude){
    const T_max = 5000;
    const altitudeFactor = Math.exp(-altitude/10000);
    return T_max * throttle * altitudeFactor;
}
function consumeFuel(throttle, dt){
    const consumed = fuelRateMax * throttle * dt;
    fuel = Math.max(fuel - consumed, 0);
}

// ----- 天候パーティクル（雨） -----
const rainCount = 1000;
const rainGeo = new THREE.BufferGeometry();
const rainPositions = [];
for(let i=0;i<rainCount;i++){
    rainPositions.push(Math.random()*200-100, Math.random()*100+50, Math.random()*200-100);
}
rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(rainPositions,3));
const rainMat = new THREE.PointsMaterial({color:0xaaaaff,size:0.1});
const rain = new THREE.Points(rainGeo,rainMat);
scene.add(rain);
function updateRain(dt){
    const pos = rain.geometry.attributes.position.array;
    for(let i=1;i<pos.length;i+=3){
        pos[i]-=50*dt;
        if(pos[i]<0) pos[i]=Math.random()*100+50;
    }
    rain.geometry.attributes.position.needsUpdate = true;
}

// ----- 飛行機更新 -----
function updatePlane(dt){
    // 操縦応答遅れ
    pitchInputFiltered += (pitchInput-pitchInputFiltered)*dt/controlLag;
    rollInputFiltered += (rollInput-rollInputFiltered)*dt/controlLag;
    yawInputFiltered += (yawInput-yawInputFiltered)*dt/controlLag;

    // 空気密度・速度・迎角
    const rho = airDensity(position.y);
    const speed = velocity.length();
    const aoa = rotation.x;

    // 揚力・抗力・推力
    const lift = 0.5*rho*speed*speed*wingArea*liftCoefficient(aoa);
    const drag = 0.5*rho*speed*speed*wingArea*dragCoefficient(aoa);
    const thrust = thrustCurve(throttle, position.y);

    consumeFuel(throttle, dt);
    const currentMass = mass + fuel;

    const force = new THREE.Vector3(0,lift-currentMass*g,thrust).add(windForce());
    velocity.add(force.clone().multiplyScalar(dt/currentMass));
    position.add(velocity.clone().multiplyScalar(dt));

    angularVelocity.x += pitchInputFiltered*dt;
    angularVelocity.y += yawInputFiltered*dt;
    angularVelocity.z += rollInputFiltered*dt;
    rotation.x += angularVelocity.x*dt;
    rotation.y += angularVelocity.y*dt;
    rotation.z += angularVelocity.z*dt;

    plane.position.copy(position);
    plane.rotation.copy(rotation);
    camera.position.copy(position.clone().add(new THREE.Vector3(0,5,15).applyEuler(rotation)));
    camera.lookAt(position);
}

// ----- HUD 更新 -----
function updateHUD(){
    document.getElementById('speed').innerText = `Speed: ${velocity.length().toFixed(1)} m/s`;
    document.getElementById('altitude').innerText = `Altitude: ${position.y.toFixed(1)} m`;
    document.getElementById('aoa').innerText = `AoA: ${(rotation.x*180/Math.PI).toFixed(1)}°`;
    document.getElementById('thrust').innerText = `Thrust: ${thrustCurve(throttle, position.y).toFixed(0)} N`;
    document.getElementById('fuel').innerText = `Fuel: ${fuel.toFixed(1)} kg`;
    document.getElementById('compass').innerText = `Heading: ${(rotation.y*180/Math.PI).toFixed(1)}°`;
}

// ----- 水平儀 -----
function updateArtificialHorizon(){
    const canvas = document.getElementById('artificialHorizon');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle='#87CEEB';
    ctx.fillRect(0,0,canvas.width,canvas.height/2);
    ctx.fillStyle='#228B22';
    ctx.fillRect(0,canvas.height/2,canvas.width,canvas.height/2);
    ctx.save();
    ctx.translate(canvas.width/2,canvas.height/2);
    ctx.rotate(-rotation.z);
    ctx.strokeStyle='white';
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(-canvas.width/2,0);
    ctx.lineTo(canvas.width/2,0);
    ctx.stroke();
    ctx.restore();
}

// ----- アニメーションループ -----
let lastTime = performance.now();
function animate(){
    requestAnimationFrame(animate);
    const now = performance.now();
    const dt = (now-lastTime)/1000;
    lastTime = now;

    updatePlane(dt);
    updateRain(dt);
    updateHUD();
    updateArtificialHorizon();
    renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
